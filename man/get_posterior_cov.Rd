% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/inference_posterior.R
\name{get_posterior_cov}
\alias{get_posterior_cov}
\title{Compute posterior covariance matrix block}
\usage{
get_posterior_cov(map, zpost, U, obs, row_idcs, col_idcs, ret.dep = FALSE)
}
\arguments{
\item{map}{Mapping object. Usually a compound map, see \code{\link{create_compound_map}}}

\item{zpost}{Vector of posterior estimates of the independent variables (i.e., associated with nodes without parent nodes)}

\item{U}{Prior covariance matrix of the independent variables}

\item{obs}{Vector with observed values of dependent nodes. Must be of same
size as \code{zprior}. An \code{NA} value in this vector means that the
corresponding variable was not observed.}

\item{row_idcs}{Indices associated with the variables of interest determining
the number of rows of the posterior covariance matrix block}

\item{col_idcs}{Indices associated with the variables of interest determining
the number of columns of the posterior covariance matrix block}

\item{ret.dep}{If \code{TRUE}, return the covariance matrix block for the
dependent variables, otherwise of the independent variables.
Default is \code{FALSE}.}
}
\value{
Return the posterior covariance matrix block \mjseqn{\Sigma_{I,J}}
with the indices \mjseqn{I} specified in \code{row_idcs} and and the
indices in \mjseqn{J} specified in \code{col_idcs}.
}
\description{
\loadmathjax
Compute the covariance matrix between selected elements
according to the posterior distribution.
}
\note{
The posterior covariance matrix block is an approximation to the true posterior
covariance matrix. It can be expected to be good if the non-linear relationships
in the Bayesian network defined by \code{map} are in good approximation linear
in the domain associated with significant values of the posterior density
function.
}
\examples{
library(Matrix)
params <- list(
  mapname = "mymap",
  maptype = "linearinterpol_map",
  src_idx = 1:10,
  tar_idx = 11:15,
  src_x = 1:10,
  tar_x = 3:7
)
mymap <- create_linearinterpol_map()
mymap$setup(params)

U <- Diagonal(n=15, x=c(rep(1e3, 10), rep(1, 5)))
zprior <- rep(0, 15)
zref <- rep(0, 15)
obs <- c(rep(NA,10), 5:9)

# glsalgo only works for linear relationships
# LMalgo can also deal with non-linear relationships
zpost <- glsalgo(mymap, zprior, U, obs)
optres <- LMalgo(mymap, zprior, U, obs)
zpost2 <- optres$zpost

# posterior estimates of values on computational grid
zpost[1:10]
# posterior estimates of error variables associated with observations
zpost[11:15]
# get posterior covariance block of independent variables
get_posterior_cov(mymap, zpost, U, obs, 1:5, 5:10)
# draw samples of independent variables from posterior distribution
get_posterior_sample(mymap, zpost, U, obs, 10)
}
